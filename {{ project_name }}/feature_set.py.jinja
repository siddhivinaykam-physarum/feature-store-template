from feature_store_dsl.types.feature import BatchEventFeature, Window, WindowType, Feature
from feature_store_dsl.types.aggregation import AggregationOperation
from feature_store_dsl.types.source import ExternalTable, EntityIdColumns, Table
from feature_store_dsl.io.sources.PostgresSource import PostgresSource
from feature_store_dsl.types.entity import BaseEntity, DataType, Entity
from feature_store_dsl.types.feature_set import FeatureSet
from feature_store_dsl.io.sinks.PostgresSink import PostgresSink
from openapi_client import ApiClient, Configuration


source = PostgresSource(
    jdbc_url="jdbc:postgresql://localhost:5432/mydb",
    user="admin",
    password="secret",
    tables=""
)

sink = PostgresSink(
    jdbc_url="jdbc:postgresql://localhost:5432/mydb",
    user="admin",
    password="secret",
    schema="public"
)

entity = BaseEntity(
    name="user_id_updated_re_re",
    output_column="id",
    data_type=DataType.STRING
)

table = ExternalTable(
    source=source,
    entity_id_columns=[EntityIdColumns(
        entity=entity,
        entity_key_column="purchase_price"
    )],
    table_time_semantics=None,
    name="checkouts_updated",
    description=""
)

window = Window(window_type=WindowType.DAY_WINDOW, window_size=7)

@EventFeature(
        name="count_user_refunds",
        description="",
        entity_restrictions=[],
        aggregation=AggregationOperation.COUNT,
        table=table,
        window=window
)
def count_user():
    return "refund_amt"


@feature_set(
    orchestrator="emr",
    orchestrator_config_path="./config/orchestrator.yml"
)
def sample_feature_set():
    return FeatureSet(
        name="{{ project_name }}",
        features=[count_user],
        table=None,
        description="",
    )
